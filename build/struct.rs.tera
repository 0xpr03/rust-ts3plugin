{% import "macros.tera" as macros %}
{% if s.do_struct %}
{% if s.documentation %}
/// {{ s.documentation }}
{% endif %}
#[derive(Debug, Clone)]
{% if s.public %}
pub {% endif %}struct {{ s.name }} {
{% for prop in s.properties %}
	{{ prop.name }}: {% if prop.result %}
Result<{{ prop.type_s }}, ::Error>{% else %}
{{ prop.type_s }}{% endif %},
{% endfor %}

{{ s.extra_attributes | indent(depth=1) }}}

{% endif %}
{% if s.do_impl or s.do_api_impl or s.do_update or s.do_constructor or s.extra_implementation %}
	{% set impl = true %}
impl {{ s.name }} {
{% endif %}
{% if s.do_impl %}
{% for prop in s.properties %}
	{% if prop.public %}
{{ macros::do_doc(prop=prop,depth=1) }}{% endif %}
	#[inline]
	{% if prop.public %}
	pub {% else %}	{% endif %}
fn get_{{ prop.name }}(&self) -> {{ prop.return_type }} {
		{{ prop.getter_body }}
	}
{% endfor %}

{% endif %}
{% if s.do_update %}
	{% for prop in s.properties %}
	{% if prop.update_body %}
	fn update_{{ prop.name }}(&mut self) {
		self.{{ prop.name }} = {{ prop.update_body }}
	}
	{% endif %}
	{% endfor %}

	fn update(&mut self) {
		{% for prop in s.properties %}
		{% if prop.update_body %}
		self.update_{{ prop.name }}();
		{% endif %}
		{% endfor %}
	}

	fn update_from(&mut self, other: &Self) {
		{% for prop in s.properties %}
		{% if prop.result %}
		if self.{{ prop.name }}.is_err() {
			self.{{ prop.name }} = other.{{ prop.name }}.clone();
		}
		{% endif %}
		{% endfor %}
	}

{% endif %}
{% if s.do_constructor %}
	fn new({{ s.constructor_args }}) -> {{ s.name }} {
{{ s.extra_initialisation | indent(depth=2) }}
		{{ s.name }} {
		{% for prop in s.properties %}
			{{ prop.name }}: {{ prop.constructor_body }},
		{% endfor %}

{{ s.extra_creation | indent(depth=3) }}
		}
	}

{% endif %}
{% if s.do_impl %}
{% if impl %}
{{ s.extra_implementation | indent(depth=1) }}}

{% endif %}
{% if s.do_api_impl %}
impl<'a> {{ s.api_name }}<'a> {
{% for prop in s.properties %}
	{% if prop.api_getter %}
{{ macros::do_doc(prop=prop,depth=1) }}	#[inline]
	pub fn get_{{ prop.name }}(&self) -> {{ prop.return_type }} {
		match self.data {
			Ok(data) => data.get_{{ prop.name }}(),
			Err(_)   => Err(Error::Ok),
		}
	}
	{% endif %}
{% endfor %}
{% if s.do_properties %}

	pub {% else %}	{% endif %}fn properties(&self) -> Vec<{{ s.api_name }}Property> {
		let mut v = vec![
			{% for prop in s.properties %}
			{% if prop.result and prop.api_getter %}
			{{ s.api_name }}Property {
				property: {{ s.api_name }}PropertyList::{{ prop.name | simplify  | title }},
				data: self.get_{{ prop.name }}().map(|p| {{ s.api_name }}PropertyType::{{ prop.type_s | simplify  | title }}(p)),
			},
			{% endif %}
			{% endfor %}
{{ s.extra_properties | indent(depth=3) }}
		];
		v.retain(|p| if let Err(Error::Ok) = p.data {
			false
		} else {
			true
		});
		v
	}
{% endif %}
}

{% endif %}
{% if s.do_properties %}
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum {{ s.api_name }}PropertyType<'a> {
{% for t in property_types %}
	{{ t.0 | simplify | title }}({{ t.1 }}),
{% endfor %}
{{ s.extra_property_type | indent(depth=1) }}
}

#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub enum {{ s.api_name }}PropertyList {
{% for prop in properties %}
{% if prop.result and prop.api_getter %}
{{ macros::do_doc(prop=prop,depth=1) }}	{{ prop.name | title }},
{% endif %}
{% endfor %}
{{ s.extra_property_list | indent(depth=1) }}
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct {{ s.api_name }}Property<'a> {
	property: {{ s.api_name }}PropertyList,
	data: Result<{{ s.api_name }}PropertyType<'a>, Error>,
}

impl<'a> {{ s.api_name }}Property<'a> {
	pub fn property(&self) -> {{ s.api_name }}PropertyList {
		self.property
	}
	pub fn data(&self) -> Result<{{ s.api_name }}PropertyType<'a>, Error> {
		//self.data.as_ref().map_err(|e| *e)
		self.data.clone()
	}
}

pub type {{ s.api_name }}Changes<'a> = Vec<(Option<{{ s.api_name }}Property<'a>>, {{ s.api_name}}Property<'a>)>;

fn get_{{ s.api_name | lower }}_changes<'a>(mut old: Vec<{{ s.api_name }}Property<'a>>,
	new: Vec<{{ s.api_name }}Property<'a>>)
	-> {{ s.api_name }}Changes<'a> {
	new.into_iter().filter_map(|p| {
		if let Some(i_old) = old.iter()
			.position(|p_old| p_old.property == p.property) {
			let p_old = old.remove(i_old);
			if p_old == p {
				None
			} else {
				Some((Some(p_old.clone()), p))
			}
		} else {
			Some((None, p))
		}
	}).collect()
}
{% endif %}
